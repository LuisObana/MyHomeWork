## COMMUNICATIONS USING PUBLIC-KEY CRYPTOGRAPHY

A symmetric algorithm can be likened to a safe, where the key functions as the combination (Schneier, 2015). Possessing the correct combination allows one to open the safe, insert or retrieve a document, and close it [1]. Without the combination, individuals are compelled to resort to safecracking to gain access [1]. According to Schneier, In 1976, Whitfield Diffie and Martin Hellman introduced a groundbreaking concept in cryptography known as public-key cryptography. Unlike traditional symmetric algorithms, public-key cryptography involves two distinct keys—one public and one private. The public key can be used by anyone to encrypt a message, but only the person with the private key can decrypt it. This system is likened to a mailbox, where anyone can drop in mail (encrypt with the public key), but retrieving the mail (decrypting with the private key) is computationally challenging without the proper key, making it a significant advancement in cryptographic security. The process of public-key cryptography is rooted in trap-door one-way functions. Encryption, the easy direction, involves using the public key to encode a message, making it accessible to anyone. On the other hand, decryption, the challenging direction, requires the private key to unravel the encoded message. The difficulty is designed to be formidable, even for powerful computers, ensuring that decryption without the private key is practically impossible within a reasonable timeframe. The private key serves as the secret or trapdoor, allowing for effortless decryption when possessed [1]. 

A simple illustration from the book:
    Alice and Bob agree on a public-key cryptosystem.
    Bob sends Alice his public key.
    Alice encrypts her message using Bob's public key and sends it to Bob.
    Bob decrypts Alice's message using his private key.

Public-key cryptography effectively addresses the key-management challenge posed by symmetric cryptosystems. In traditional systems, Alice and Bob had to secretly agree on a key, requiring prearrangement and secure transmission. Public-key cryptography simplifies this process. Without prior agreements, Alice can securely send a message to Bob. Even if Eve intercepts the exchange, having Bob's public key and an encrypted message, she cannot decipher Bob's private key or the actual message. This innovation enables secure communication without the need for prior key exchange arrangements. 

More commonly, a network of users agrees on a public-key cryptosystem. Every user has his or her own public key and private key, and the public keys are all published in a database somewhere. Now the protocol is even easier:

    Alice gets Bob's public key from the database.
    Alice encrypts her message using Bob's public key and sends it to Bob.
    Bob then decrypts Alice's message using his private key.

In the first protocol, Bob had to send Alice his public key before she could send him a message. The second protocol is more like traditional mail. Bob is not involved in the protocol until he wants to read his message.

### Hybrid Cryptosystems

The emergence of public-key algorithms coincided with the proposal of DES as a standard, leading to some controversy in the cryptographic community. The NSA's support for DES, criticized by Diffie and Hellman, sparked debates resembling partisan politics. Public-key cryptography faced resistance and was portrayed as a competing product rather than a research discovery [1].

In practical terms, public-key algorithms do not replace symmetric algorithms but complement them. Public-key cryptography is used to encrypt and distribute session keys, which are then employed by symmetric algorithms to secure message traffic. This hybrid approach addresses key-management challenges, minimizing the risk of compromising session keys compared to traditional symmetric cryptography. The protocol involves exchanging public keys, generating session keys, and using them for secure communication, providing a more secure and efficient cryptographic solution [1].

### Merkles Puzzles

Ralph Merkle pioneered the first concept of public-key cryptography in 1974. Despite facing initial difficulty in conveying his idea to his instructor, Lance Hoffman, Merkle continued to develop his approach. His technique involved the use of "puzzles," making it easier for the sender and receiver, but considerably more challenging for an eavesdropper like Eve [1].

In Merkle's system:
    •	Bob generates a large number of messages with randomized content and encrypts each with a unique key, sending them to Alice.
    •	Alice selects a message at random and employs a brute-force attack to recover the plaintext.
    •	Alice encrypts her secret message using the key obtained and sends it, along with the randomly chosen message identifier, to Bob.
    •	Bob, aware of the secret key used in the selected message, decrypts Alice's message.

Although Eve can break the system, doing so requires significantly more effort than what Alice and Bob expend. Eve needs to perform a brute-force attack against all of Bob's messages, resulting in a computational effort roughly proportional to the square of Alice's. While this advantage is relatively small in cryptographic terms, it can be effective in certain scenarios. The system's security relies on the substantial computational effort required by Eve, making it a viable cryptographic solution under certain conditions [1].

## DIGITAL SIGNATURES

Handwritten signatures have been historically valued for several reasons, though some of the commonly believed attributes about signatures are not entirely accurate [1]:

    •	Authenticity: Signatures are believed to be authentic, convincing the recipient that the signer intentionally signed the document.
    •	Unforgeability: Signatures are thought to be unforgeable, serving as proof that only the signer deliberately signed the document.
    •	Non-reusability: Signatures are perceived as non-reusable; they are considered integral to a specific document and cannot be moved to another.
    •	Unalterability: Once a document is signed, it is assumed to be unalterable.
    •	Non-repudiation: Signatures and documents are considered physical entities, preventing signers from later disavowing their signatures.

In reality, these assertions about signatures are not entirely true. Signatures can be forged, moved to different documents, and documents can be altered post-signing. Despite these vulnerabilities, we accept these imperfections due to the inherent difficulty in cheating and the associated risk of detection [1].

Applying similar principles to digital signatures on computers poses challenges. Computer files are easily copied and modified without leaving evidence, making it challenging to replicate the level of trust associated with physical signatures. The ease of copying and modifying digital files complicates the establishment of authenticity, unforgeability, non-reusability, unalterability, and non-repudiation in the digital realm [1].

### Signing Documents with Symmetric Cryptosystems and an Arbitrator

In this scenario, Alice uses a protocol involving Trent, a trusted arbitrator, to sign a digital message and send it to Bob. The process involves encryption and decryption with shared secret keys. The characteristics of this digital signature method are evaluated [1]:

    • Authenticity: Trent's certification serves as proof to Bob that the message is authentic and came from Alice. Trent, being a trusted arbitrator, ensures the legitimacy of the message.
    •	Unforgeability: The use of secret keys (KA and KB) ensures that only Alice could have sent a message encrypted with KA. Trent's involvement adds an extra layer of trust, making it difficult for impostors to forge messages.
    •	Non-reusability: If someone attempts to reuse Trent's certification on another message, an arbitrator can verify the mismatch by encrypting the message with KA, proving the attempt at reuse.
    •	Unalterability: Trent can detect any attempt to alter the document after receipt by comparing the encrypted message with KA to the original.
    •	Non-repudiation: Trent's certification prevents Alice from later denying that she sent the message. His trustworthiness establishes the validity of the signed document.

However, this method has drawbacks, especially the reliance on Trent as a central figure:  

    •	Time-Consuming: Trent acts as an intermediary for all signed documents, making the process time-consuming.
    •	Bottleneck: Trent becomes a bottleneck in the communication system, potentially slowing down the exchange of signed messages.
    •	Trust in Trent: Creating and maintaining a trusted arbitrator like Trent is challenging. Trent must be infallible and completely secure. Any mistake or compromise in Trent's security could lead to chaos, with forged documents and potential societal collapse.

In practice, the theoretical framework of this system faces significant challenges and limitations, making it less practical for widespread use [1].

### Digital Signature Trees

Ralph Merkle introduced a digital signature scheme relying on secret-key cryptography, utilizing a tree structure to generate an infinite number of one-time signatures. In this scheme, the root of the tree is placed in a public file, serving as an authentication mechanism. The root signs a message and authenticates its sub-nodes within the tree. Each node in the tree signs a message and authenticates its own sub-nodes, creating a hierarchical and expandable structure for digital signatures [1].

### Signing Documents with Public-Key Cryptography

Public-key algorithms, such as RSA and DSA, can be employed for digital signatures. In RSA, either the public or private key can be used for encryption, allowing for secure digital signatures. In DSA, a separate algorithm specifically designed for digital signatures is utilized. The basic protocol involves Alice encrypting a document with her private key, signing the document, and then sending the signed document to Bob. Bob verifies the signature by decrypting the document with Alice's public key. This protocol eliminates the need for a third party, such as Trent, for signing or verifying signatures. The characteristics of this protocol include authenticity, unforgeability, non-reusability, unalterability, and non-repudiation. Bob can independently verify the signature without requiring Alice's assistance.

### Signing Documents and Timestamps

Digital signatures can be vulnerable to cheating in certain situations, such as when Bob can reuse the document and signature. For example, if Alice signs a digital check for $100 and Bob saves a copy, he could attempt to deposit it repeatedly without Alice's knowledge. To prevent such abuse, digital signatures often include timestamps, indicating the date and time of the signature. The timestamp is attached to the message and signed along with the rest of the content. The bank stores this timestamp in a database, enabling it to detect attempts at cashing the same check multiple times. If Bob tries to deposit Alice's check a second time, the bank checks the timestamp against its records, identifies the duplicate attempt, and takes appropriate action, such as alerting the authorities. This preventive measure helps maintain the integrity and security of digital signatures, deterring fraudulent activities.

### Signing Documents with Public-Key Cryptography and One-Way Hash Functions

In practical implementations, public-key algorithms can be inefficient for signing long documents. To optimize efficiency, digital signature protocols often employ one-way hash functions. In this approach, Alice signs the hash of the document instead of the document itself. The protocol involves producing a one-way hash of the document, encrypting the hash with Alice's private key to sign the document, and then sending both the document and the signed hash to Bob. To verify the signature, Bob produces a hash of the received document and decrypts the signed hash using Alice's public key. If the two hashes match, the signature is valid.

This method significantly enhances speed, and the low probability of different documents having the same hash ensures the security of equating a signature of the hash with a signature of the document. Using a one-way hash function prevents the creation of multiple documents with the same hash value, maintaining the integrity of the signature.

Beyond speed and security, this protocol allows the signature to be kept separate from the document, and recipients require less storage for both. An archival system could use this protocol to verify the existence of documents without storing their contents. Users submit hashes to a central database, which timestamps and stores them. This system has privacy implications, enabling individuals like Alice to copyright a document while keeping its contents secret. Only when necessary to prove copyright would the document need to be made public.

### Algorithms and Terminology

There are numerous digital signature algorithms, all of which are public-key systems with secret keys for signing and public keys for verification. Although the signing process is occasionally referred to as encrypting with a private key and verification as decrypting with a public key, this only holds true for the RSA algorithm. Each algorithm has its own implementations, and additional steps like one-way hash functions and timestamps may be included in the signing and verifying processes. While multiple algorithms can be used for digital signatures, they might not be suitable for encryption.

In general terms, the signing process involves using a private key, denoted as SK(M), and the verification process uses the corresponding public key, denoted as VK(M). The bit string attached to the document during signing, referred to as the digital signature or simply the signature, serves as a means of authentication. The overall protocol, ensuring the receiver's confidence in the sender's identity and the message's integrity, is known as authentication.

### Multiple Signatures

In the absence of one-way hash functions, Alice and Bob have two options for signing the same digital document. First, they can sign separate copies of the document, resulting in a message over twice the size of the original. Second, Alice can sign the document, and then Bob signs Alice's signature. However, with this method, it becomes impossible to verify Alice's signature without also verifying Bob's.

With the use of one-way hash functions, multiple signatures become more efficient:

    •	Alice signs the hash of the document.
    •	Bob signs the hash of the document.
    •	Bob sends his signature to Alice.
    •	Alice sends the document, her signature, and Bob's signature to Carol.
    •	Carol verifies both Alice's signature and Bob's signature.

Steps (1) and (2) can be done in parallel or in series. In step (5), Carol can verify one signature without having to verify the other. This approach allows for multiple parties to sign the same document in a more streamlined manner, leveraging the benefits of one-way hash functions.

### Nonrepudiation and Digital Signatures

Alice can potentially cheat with digital signatures through a method called repudiation, where she signs a document and later denies doing so. She can claim that her private key was compromised, either by anonymously publishing it, losing it in a public place, or pretending to do so. Timestamps can mitigate this cheating, but Alice may still claim her key was compromised earlier. To prevent abuse, private keys are often stored in tamper-resistant modules.

While it's challenging to prevent this kind of abuse, steps can be taken to ensure that old signatures are not invalidated during disputes over new ones. One solution is to timestamp signed documents. The protocol involves:

    •	Alice signs a message.
    •	Alice generates a header with identifying information, concatenates it with the signed message, signs the combination, and sends it to Trent.
    •	Trent verifies the outside signature, confirms the identifying information, adds a timestamp to Alice's signed message, and signs it all. He sends it to both Alice and Bob.
    •	Bob verifies Trent's signature, the identifying information, and Alice's signature.
    •	Alice verifies the message Trent sent to Bob. If she didn't originate the message, she can quickly raise the issue.

Another scheme involves Trent verifying signed messages after the fact. Bob sends a copy of a signed message to Trent for verification, and Trent can attest to the validity of Alice's signature. These measures aim to add layers of verification and accountability to the digital signature process.

### Applications of Digital Signatures

One of the earliest proposed applications of digital signatures was for verifying nuclear test ban treaties between the United States and the Soviet Union. Both nations allowed the placement of seismometers on each other's soil to monitor nuclear tests. The challenge was ensuring that the host nation did not tamper with the monitoring nation's seismometer data and that the monitor sent only the required information for monitoring. Conventional authentication techniques could address the first problem, but digital signatures were crucial for solving both issues. With digital signatures, the host nation could read the data from the seismometer without altering it, and the monitoring nation could be confident that the data remained untampered.

## DIGITAL SIGNATURES WITH ENCRYPTION

Combining digital signatures with public-key cryptography results in a protocol that combines the security of encryption with the authenticity of digital signatures. In this protocol:
    
    •	Alice signs the message with her private key: SA(M).
    •	Alice encrypts the signed message with Bob's public key and sends it to Bob: EB(SA(M)).
    •	Bob decrypts the message with his private key: DB(EB(SA(M))) = SA(M).
    •	Bob verifies with Alice's public key and recovers the message: VA(SA(M)) = M.

Signing before encrypting is a natural practice, analogous to putting a signed letter in an envelope. This order is more secure, as adversaries cannot remove a signature from an encrypted message and add their own. Additionally, legal considerations favor signing before encrypting, ensuring the signer has visibility into the text when affixing their signature.

Alice can use separate public-key/private-key pairs for encryption and signatures, providing advantages such as surrendering one key without compromising the other, independent escrow possibilities, and flexibility in key sizes and expiration times. Timestamps should be incorporated into the protocol to prevent message reuse and address potential pitfalls.

### Resending the Message as a Receipt

In an implementation of the protocol with confirmation messages:
    
    •	Alice signs a message with her private key, encrypts it with Bob's public key, and sends it to Bob: EB(SA(M)).
    •	Bob decrypts the message with his private key and verifies the signature with Alice's public key, confirming Alice's signature and recovering the message: VA(DB(EB(SA(M)))) = M.
    •	Bob signs the message with his private key, encrypts it with Alice's public key, and sends it back to Alice: EA(SB(M)).
    •	Alice decrypts the message with her private key and verifies the signature with Bob's public key. If the resultant message matches the one she sent to Bob, she knows that Bob received the message accurately.

However, if the same algorithm is used for both encryption and digital-signature verification, a possible attack exists. The digital signature operation is the inverse of the encryption operation: Vx = Ex and Sx = Dx. In this scenario, Mallory, a legitimate system user with his own public and private key, can exploit this vulnerability.

Mallory records Alice's message to Bob and later sends that message to Bob, claiming it came from him. Bob decrypts the message with his private key and tries to verify Mallory's signature. The resultant message is gibberish (EM(DA(M))), but Bob sends Mallory a receipt (EM(DB(EM(DA(M))))). Mallory can then manipulate the receipt to obtain the original message (M).

The insecurity arises from Bob's willingness to acknowledge the receipt of gibberish. If Bob checked the message for comprehensibility before sending a receipt, this security problem could be avoided. There are also enhancements to this attack that allow Mallory to send Bob a different message than the one he eavesdropped on. The key lesson is not to sign arbitrary messages from others or decrypt arbitrary messages and share the results with others to avoid these security risks.

### Foiling the Resend Attack

To ensure security in public-key cryptography protocols and avoid the described attack, it's crucial to use different operations for encryption and digital signatures. This can be achieved by employing different keys for each operation or using distinct algorithms for encryption and signature. Timestamps, making incoming and outgoing messages different, and utilizing digital signatures with one-way hash functions also contribute to security.

  A secure public-key cryptography protocol involves the following steps:
    •	Alice signs a message.
    •	Alice encrypts the message and signature with Bob's public key, using a different encryption algorithm than for the signature.
    •	Bob decrypts the message with his private key.
    •	Bob verifies Alice's signature.

### Attack against Public-Key Cryptopgraphy

When using public-key cryptography protocols, obtaining Bob's public key is a critical consideration. The most straightforward method is accessing a secure public database containing everyone's public keys. However, this database must be public and protected from unauthorized write access to prevent malicious substitutions by an attacker like Mallory. Even with secure databases, Mallory could attempt substitution during transmission. To counter this, a Key Certification Authority or Key Distribution Center (KDC), often represented by Trent, can sign each public key with its private key.

In practical implementations, the KDC signs a compound message containing the user's name, public key, and other pertinent information, storing it in the database. When Alice retrieves Bob's key, she verifies the KDC's signature to ensure the key's validity. While this adds complexity and difficulty for Mallory, it does not make attacks impossible. Mallory would need to substitute his own public key for the KDC's key, corrupt the database, and replace valid keys with his own (all signed with his private key as if he were the KDC).

## RANDOM AND PSEUDO-RANDOM-SEQUENCE GENERATION

Random-number generation is a crucial aspect of cryptography, and relying on standard compiler-built generators is not recommended due to their lack of security and randomness. While these generators may be suitable for simple applications like computer games, cryptography demands a higher level of randomness to avoid correlations and ensure security.

The challenge lies in the nature of computer-generated random numbers. Computers are deterministic, processing inputs through predictable operations to produce consistent outputs. As John von Neumann noted, attempting to generate truly random digits through arithmetic methods on a computer is considered a futile endeavor. The deterministic nature of computers implies that any random-number generator, operating within a finite set of states, is inherently periodic and, consequently, predictable. This predictability undermines the randomness required for secure cryptographic applications.

In summary, traditional random-number generators on computers lack the essential randomness needed for cryptographic purposes. True randomness involves an element of unpredictability that a computer, as a deterministic machine, cannot provide without external random input.

### Pseudo-Random Sequences

A pseudo-random-sequence generator is the best a computer can produce, and it aims to generate sequences that appear random. The defining characteristics of a good pseudo-random sequence include a sufficiently long period to avoid predictability in practical use, indistinguishability from truly random sequences, and passing various statistical tests for randomness. Properties such as an equal distribution of ones and zeros, randomness in run lengths, and resistance to compression contribute to the effectiveness of a pseudo-random generator. While all generators are inherently periodic, their large potential periods (e.g., 2^256 bits) make them suitable for extensive applications. However, the challenge lies in addressing correlations and unexpected patterns that cryptanalysts might exploit in attacks.

### Cryptographically Secure Pseudo-Random Sequences

In cryptographic applications, a pseudo-random-sequence generator must meet more stringent requirements than in other contexts. Cryptographic randomness involves statistical randomness, but crucially, the sequence must also be unpredictable. It should be computationally infeasible to predict the next bit, even with complete knowledge of the algorithm, hardware, and previous bits. Cryptographically secure pseudo-random sequences should resist compression unless the key (typically the seed setting the initial state) is known. These generators, like cryptographic algorithms in general, are susceptible to attack, and enhancing resistance to attacks is a central goal in cryptography.

### Real Random Sequences

In the realm of philosophers, questions arise about the nature of randomness and how to define a random sequence. While quantum mechanics suggests genuine randomness in the physical world, the challenge lies in preserving this randomness in the deterministic realm of computers. From a practical standpoint, a sequence generator is considered truly random if it possesses a third property:

It cannot be reliably reproduced. Running the sequence generator twice with the same input should yield two entirely unrelated random sequences.

Generators meeting these three properties are suitable for cryptographic applications like one-time pads and key generation. However, determining whether a sequence is genuinely random presents a challenge, as repeated encryption with a fixed key may produce a seemingly random output, making it difficult to discern non-randomness without significant computational resources.

## Cryptographic hash functions and digital signatures

### Typical use of digital signatures

Suppose you want to send your favorite cat picture to your friend Fred via email, but you suspect the picture might be, maliciously or accidentally, corrupted during transfer. How would you and Fred make sure the picture Fred receives is exactly the same as the one you send?

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/b7185de5-9348-4196-bb4d-ad49a98de3ce)

You can include a digital signature of the cat picture in the email. Fred can then verify this digital signature to make sure the cat picture is authentic. You can do this in 3 different phases: 

    Step 1 of the digital signature process, you generate a private key for creating digital signatures and a corresponding public key for verification. The public key is shared with others, like Fred, in person to ensure its authenticity.
    Step 2, you sign an email and its attached cat picture using your private key, producing a digital signature. This signed content is then sent to Fred.
    Step 3, Fred receives the email and, using the public key obtained in Step 1, verifies the digital signature. If the signature or the cat picture has been altered since the signature was created, the verification will fail.

### Improving cookie token security


Lisa, facing challenges in recognizing individuals and detecting dishonest behavior in the company's growing environment, considers implementing a solution for secure cookie token transfers. She contemplates having everyone digitally sign their token transfers by including a message and a digital signature in an email, as illustrated in Figure 2.14.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/a5704677-3d48-4220-85a0-6b92efe957e2)

Suppose John is the new guy at the office. The company gave him some cookie tokens as a welcome gift when he started. Now, John wants to buy a cookie in the cafe for 10 CT. He needs to digitally sign a cookie token transfer. Figure 2.15 shows what he has to do.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/41c762a6-0ffa-4d90-8046-7c93dcffc473)

Just as with the email to Fred in the previous section, there are three phases in this process (please compare with the steps in figure 2.13 to see the similarities):

    1 John prepares by generating a key pair. John keeps the private key secret and hands the public key over to Lisa. This is a one-time setup step.
    2 John wants a cookie. He writes a message and signs it with his private key. He sends the message and the digital signature in an email to Lisa.
    3 Lisa verifies the signature of the message using John’s public key and updates the spreadsheet.

### Key pair reuse

A key pair is created once. The same private key can be used several times to digitally sign stuff.

### Preparation: John generates a key pair

To enable signing payments, John initiates the creation of a key pair. This involves generating a private key and subsequently calculating the corresponding public key. The process is illustrated in Figure 2.16. The private key is essential for John to sign payments, while Lisa will require John's public key for verifying his signatures.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/c607d059-3e68-4f2c-b289-d5e986af3ccc)


John begins the key pair creation process by utilizing a random number generator to produce a substantial 256-bit random number, which becomes his private key. Following this, the private key undergoes transformation into a public key through the use of a public-key derivation function.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/ccb6fa4c-77ad-4f02-be26-9c3997541d5f)


The public key is 33 bytes (66 hex digits) in length, slightly longer than the private key, which is 32 bytes (64 hex digits) long. The additional byte in the public key is related to the workings of the public-key derivation function, a complex topic that doesn't require in-depth understanding for users to grasp how signatures function from their perspective.

### Two ways to use the key pair

Keys, including private and public keys, play a crucial role in encryption and decryption processes. Encryption ensures that messages are only readable by individuals possessing the correct decryption key. The private and public keys form a pair with a robust relationship: the public key encrypts messages that only the corresponding private key can decrypt, and vice versa, creating a secure communication channel (refer to Figure 2.17).

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/0ea4f924-bed4-4dcf-9f26-e9d1ca28be0d)

In the context of the left side of Figure 2.17, only John, possessing the private key, can decrypt and read the encrypted message. This feature of public and private keys is employed in scenarios where two parties wish to communicate privately, such as in online banking transactions. The presence of a padlock in the web browser's address bar indicates the use of this security process to safeguard communication.

On the right side of the figure, Lisa can decrypt the message using John's public key, corresponding to his private key. This functionality is applied in digital signatures. Unlike encrypting secret messages with the private key (which is not secure because the public key is accessible to everyone), digital signatures operate without the need for secret messages.

### Recap of key pairs

You create a key pair by first creating a private key. The private key is a huge, secret random number. The public key is then calculated from the private key.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/5647f718-a105-40c3-9c8d-43daed27ff35)

You can use the private key to encrypt a message that can be decrypted only using the public key.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/2420c334-9d45-4513-babf-8a50729fca85)

The encryption and decryption in this figure are the foundation for digital signatures. This process is not suitable for sending secret messages because the public key is usually widely known.

The reverse process is also common, in which the public key is used to encrypt and the private key is used to decrypt. This process is used to send secret messages. Bitcoin doesn’t use it.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/8593ae88-0240-4555-87f3-91e31b588c78)

John has created a pair of keys and is about to digitally sign his payment to the cafe with his private key so Lisa can verify that it’s actually John making the payment. Lisa verifies this using John’s public key.

John signs his payment. See figure below for the actual process:

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/f1a1c8e9-cd77-4d91-88a6-f87917c096ff)

The message John wants to sign is, “Lisa, please move 10CT to Cafe. /John”. The signing function will hash this message with SHA256, whose output is a 256-bit number. This hash value is then encrypted with John’s private key. The result is a digital signature that looks like this:

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/6ec96c19-1ee5-4a62-b3da-6fe58aea799f)

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/bbf087b7-0a98-4470-9173-532edd5d1fc8)

The signature is an encrypted hash of a message. If John had used another private key to sign with or a slightly different message, the signature would have looked completely different.

### Signatures in Bitcoin

This isn’t remotely similar to the previous signature. This is good for John, because he knows his signature can’t be used for messages other than his specific message.

John has now composed an email to Lisa. This email contains a message and a signature of that message. John finishes by sending the email to Lisa.

Lisa verifies the signature
Lisa looks at the email and sees it claims to be from John, so she looks up John in her table of public keys (figure 2.20).

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/54ab8b6c-dad6-401f-8357-45ad9c25901f)

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/9e6fb0e9-7517-49ec-a4d9-cc502e59e37a)

Lisa’s actions in this figure aim to determine that the cookie token transfer was signed by the private key it claims to be signed with. The message says it’s from John. She received John’s public key the other day and put that public key in her table of public keys. The things she has at hand are

        A The message “Lisa, please move 10CT to Cafe. /John”
        B The signature INxAs7oFDr8...
        C John’s public key that she just looked up in her table

John encrypted the message’s hash with his private key. This encrypted hash is the signature. If Lisa decrypts the signature B with John’s public key C, the result should be a hash that equals the hash of the message A in the email.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/c11f613c-0f22-4f3c-b121-0cef9142b8cf)

Lisa takes the signature B and decrypts it with the public key C she looked up in her table of public keys. The decryption outputs a big number. If this number is equal to the hash of the message A, it proves John’s private key was used to sign the message. Lisa takes the message A, exactly as written, and hashes that message just like John did when he created the signature. This message hash is then compared with the decrypted signature. The message hash and the decrypted signature match, which means the signature is valid.

Note that this process works only if John and Lisa use the exact same digital signature scheme. This must be agreed on beforehand, but it’s usually standardized. In Bitcoin, everyone knows exactly what digital signature scheme to use.

Lisa can now be sure no one is trying to fool her. She updates the spreadsheet with John’s transfer, as shown in figure 2.21.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/86dcf02f-cc4d-461c-9b5b-01e40ad46d06)

## PGP - Send Encrypted and Signed Message - gpg

Send a secret message over untrusted Internet. Encryption prevents anyone from reading your message. Signing protects your message from modification. Public keys allow you to establish trust without meeting physically. PGP is well known, highly secure standard for encryption.

GNU privacy guard, 'gpg', is a popular way to encrypt and sign. You're likely already depending on it, as Linux kernel development uses uses PGP signatures.

Scenario:

Alice will send an encrypted message to Tero

### Setting UP

These inital key exchange and verification steps need to be done only once. They establish trust between parties.

Generate Keypair

Let's install required tools. We interested in 'gpg' encryption tool. The others, 'micro' text editor and 'killall' from psmisc are just helpful extras.

Code:
![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/a8c95eda-cc27-4df2-8d8f-8be5c3f99f68)

Create a keypair

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/42edde61-d50e-43c0-9a83-6798ddeeb2e9)

Note: It is possible not to protect the key with a password (this example, no password was created for the key). Simple give an empty password twice and confirm that you dont want password for the key. 

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/d9cea114-83aa-4422-b8c1-d77b463b0599)

The keypair consists of public key and secret key. Secret key is, well, secret. If someone ever sees it, you would need to go to each service where it's used and disable it. Public key is, well, public. You can put it on a web page and upload it to key servers.

Publicity of the public key is the magic of the whole system. 

### Export Public Key

For Alice to send the message, a public key is needed. It has to be exported byb the creator (this example Tero has to export it). To do this, follow below codes:

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/5e713c6a-2b6f-4aa1-a82f-317d19a494d5)

Parameters to export are:
        1. export --> export the public key
        2. armor --> use only ASCII characters, so that the output can be viewed and copy pasted
        3. output tero.pub --> output will be save to the file tero.pub

See the public key:

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/7b668b43-fba2-4517-ac8d-d8e69ed839fd)

Above figure is an example of public key in ASCII armor. Notice that it **begins with Public Key** and some lines of nonsense, the actual key in ASCII armor, base64 encoded, at the end it says **END PGP PUBLIC KEY**

### Simulation of Alice

We can create Alice within the same operating system or in another computer for simulation. For this example, Alice was created on the same operating system. 

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/fdf092d1-344e-45a2-a645-67e06f9e2b8a)

A new folder was created in home directory with protection so that only owners (creator) can use it otherwise **gpg** would complain. 

To simulate, we can just work inside Alice folder and replace **gpg** with **gpg --homedir**. This way, Alice will have its own settings and own keyring, separate from the one we will use. .

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/3a8c68d2-5e1b-407f-898a-da6d66d8239d)

Everything will run in Alice directory **cd ~/alice**, and start with **gpg --homedir.**. The initial 'gpg' command creates Alice's configuration files. The use of "--homedir ." indicates that the current working directory will be used to save GPG configuration files. The command 'pwd' can be used to check the current working directory. Listing the fingerprints of all keys yields no results initially, as Alice does not yet possess any keys—neither her own nor imported keys.

Now we create Alice own keypair.

Using the same process as we use when we create own keypair

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/1713e4df-4f9c-4865-8f87-27b621bda590)

Information:
    Name: Alice
    Email: alice@example.com.invalid
    Password: empty

Alice key:

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/7c1a18ed-a777-40a7-b5ab-27fec8595203)

In most sample stories, it is Alice and Bob talking but for this example, Alice will be talking to Tero (send message). To send the message, Alice would need the public key of Tero. Since as mentioned, public key is available for public, the only thing Alice needs is to verify that the key belongs to Tero. 

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/b08c718c-6460-4dfd-8bdb-57f1b04c22d8)

Checking the fingerprint to verify the owner of the key (for this exmaple Tero) is needed of the public key was obtained over a not secure channel like unencrypted email, a web page or a key server. 

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/4438e43b-c8df-4cbe-950c-5290cfbcbff5)

One way to verify is through calling the person nd talking to them. Once connection or identity was established, you can start asking them to read out the fingerprint. 

For this example, Alice was able to verify the identity, she then signs Tero's key to mark it as trusted. Alice could also refer to keys with their email addresses. Since she is verifying the fingerprint, using it in the command protects against mistakes. 

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/c6bd60a8-3261-4ce6-a7ce-4eb33a3b9856)

Alice has ultimate trust for her own key since she generated her keypair with her own computer **--gen-key**. Now she was able to verify Tero's key,she can now encrypt messages to Tero. 

### Tero needs Alices Public Key to Know It's Her

The process is similar, only the roles were swapped. Now it is Tero who needs to verify that she is talking to Alice. 

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/4195e0ac-d581-445b-a0c9-bf6fa95b2697)

Now **Trust is Established** in both parties. Both have each others keys and verfied that it is the correct one. They only needed each others correct public keys. It can be sent through untrusted and hostile network, such as the internet. In fact, public key encryption allows establishing trust over untrusted channel.

### Alice sends the message

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/ebea3aed-6fa0-424c-b1d1-1bb137063c39)

The parts of the command are

Simulation:

--homedir . Use gpg configuration and keyring from working directory 'pwd'. We already did 'cd ~/alice', so that's what we're using. This is just for our Alice simulation here

Encrypt to Tero using Tero's public key

--encrypt Encrypt the message
--recipient tero@example.com.invalid To key identified by email address. Only keys within our keyring are considered, so it's safe to use email addresses here. Of course, fingerprints work, too. Encryption only needs one key, the public key for the recipient.
Sing using Alice's secret key

--sign Sign the message using Alice's secret key. Recipient of this message can use Alice's public key to verify that it's really her sending the message.
Output file, encrypted

--armor Use normal, printable ASCII characters for the message. This way, we can copy-paste it, and it does not break if we send it in email body. It uses base64 to show binary data using normal letters.
--output encrypted.pgp Save the encrypted message to this file
Input file, plain text

message.txt The plain text file we wish to encrypt
Encrypted message was generated.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/cb6eb0ca-5c33-451f-82b8-295e7e58e77c)

The encrypted message, encapsulated between "BEGIN PGP MESSAGE" and "END PGP MESSAGE," comprises over 20 lines of encrypted, signed, and ASCII-armored gibberish, representing Alice's secret message. Notably, even Alice herself cannot decrypt the message at this point. It has been encrypted using Tero's public key, meaning only Tero possesses the capability to decrypt and open it. The secure transmission of the encrypted message is demonstrated by simulating the transfer through actions like copying the file, allowing it to traverse potentially hostile and untrusted channels, such as the Internet.

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/7d97c1d0-932e-4cae-af62-4a738adb6201)

### Tero Decrypts and Verifies the Message

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/4361c9d7-0f02-4a0e-b10a-2860e5363a8c)

Identity was verfiied through signature verification using Alice public key. 

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/bc2b691c-7052-44e9-bb07-8525f552ceb0)

### Troubleshooting

**"gpg: agent_genkey failed: No such file or directory" - solution: 'killall gpg-agent'**

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/c7622c78-592b-46a3-9338-f8cf5a0b3fcf)

**gpg: key "B624 ... 84A3" not found: No public key' - solution: List fingerprints**

![image](https://github.com/LuisObana/MyHomeWork/assets/149092789/11357790-171e-4816-b0ea-57ab71afc20f)

## Reference:
1. 3.	PGP - Send Encrypted and Signed Message – gpg Link: 4.	https://terokarvinen.com/2023/pgp-encrypt-sign-verify/  
